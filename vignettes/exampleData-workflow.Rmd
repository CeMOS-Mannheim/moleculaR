---
title: "moleculaR: Walkthrough"
author: 
- "Denis Abu Sammour" 
- "James-Lucas Cairns"
date: "`r Sys.Date()`"
output:  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    number_sections: true
theme: cosmo
vignette: >
  %\VignetteIndexEntry{exampleData-workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style>
body {
text-align: justify}
h1.title {
  font-size: 32px;
}
h1 { /* Header 1 */
  font-size: 24px;
}
h2 { /* Header 2 */
    font-size: 20px;
}
h3 { /* Header 3 */
  font-size: 16px;
}
</style> 

```{r conf, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 6
)
```

# Introduction

The _moleculaR_ R package provides a computational framework that introduces probabilistic mapping and point-for-point statistical testing of metabolites in tissue via Mass spectrometry imaging. It enables collective projections of metabolites and consequently spatially-resolved investigation of ion milieus, lipid pathways or user-defined biomolecular ensembles within the same image.

_moleculaR_ comes pre-loaded with the SwissLipids database and with is capable of importing metabolite annotation results from the METASPACE platform to compute FDR-verified moleculaR probability maps (MPMs) and collective projection probability maps (CPPMs). 

For more information about this package and its applications please refer to the associated [preprint](https://doi.org/10.1101/2021.10.27.466114).

# Installation & Loading Example Data

_moleculaR_ can be installed via `devtools`, note that you to set `build_vignettes=TRUE` to build this vignette during package installation. Once installed, _moleculaR_ could be loaded with `library()`:

```{r setup, eval=FALSE, include=TRUE}
# not run
install.packages("devtools")
devtools::install_github("CeMOS-Mannheim/moleculaR", build_vignettes=TRUE)

library(moleculaR)

```

# Importing & Processing MSI Data

Under the hood _moleculaR_ is mainly based on `MALDIquant`, `spatstat` and `Matrix` packages and provides some additional tools to help ipmport and process any given MSI dataset. Please note that currently only *centroided* MSI data is supported. _moleculaR_ expects two mandatory data inputs; a (processed) _imzML_ file and an additional _tsv_ file which contains a full continuous spectrum (with m/z and intensity columns) which either represents a random pixel within the imaging dataset or an average spectrum. 


```{r importData, eval=FALSE, include=TRUE}
#-- not run --#

# read MSI data  
imzmlFile         <- "pathToFile.imzML" 
msData            <- readCentrData(path = imzmlFile) 

# single spectrum  
spectrFile        <- "pathToFile.tsv"                  
msSpectr          <- readSingleSpect(spectrFile) 

```

_moleculaR_ also accepts one optional input which is the annotations results for the given dataset which the user could retrieve from METASPACE (https://metaspace2020.eu) provided, of course, that the same dataset has been previously uploaded there for annotation. When this input is provided, _moleculaR_ takes these into consideration to filter out detections which were not verified by METASPACE at a certain FDR specified by the user. 

```{r import-mtspc, eval=FALSE, include=TRUE}
#-- not run --#

# load the metaspace annotations file
pathToMtspc       <- "pathToFile.csv"                 
mtspc             <- read.csv(file = pathToMtspc, skip = 2, header = TRUE, colClasses = "character")

```

Finally, the SwissLipid database, which is provided with _moleculaR_ ,must be loaded: 

```{r import-sldb, eval=FALSE, include=TRUE}
#-- not run --#

# load the processed swisslipids db 
pathTosldb        <- system.file("extdata", "swisslipids-speciesOnly-sep2020.tsv", package = "moleculaR", mustWork = TRUE)
sldb              <- loadSwissDB(pathTosldb)

```

For subsequent analysis, an S3 `fwhm` object must be created which will hold information about full width at half maximum (FWHM) as a function of m/z axis and will be used to estimate FWHM at any given m/z value (for more info see `?estimateFwhm`):  


```{r fwhm-esitmation, eval=FALSE, include=TRUE}
#-- not run --#

# estimate fwhm from msSpectr
fwhmObj           <- estimateFwhm(s = msSpectr) 
                                                            
```

Before applying any preprocessing methods, it is highly recommended to perform peak-binning and peak filtering on `msData`, subsequently the user may apply any preprocessing methods provided by `MALDIquant` (keeping in mind that this is a centroided dataset). 

```{r preproc, eval=FALSE, include=TRUE}
#-- not run --#

# bin peaks
msData            <-  MALDIquant::binPeaks(msData, 
                                           tolerance = getFwhm(fwhmObj, 400)/400, #focusing on lipids 
                                           method = "relaxed")


# filter out peaks which occur in less than 1% of the time 
# Note: use 'moleculaR::' namespace to distinguish it from MALDIquant::filterPeaks if MALDIquant is loaded.
msData            <- moleculaR::filterPeaks(x = msData, minFreq = 0.01)


```


# Walkthrough - Example Data 

_moleculaR_ also comes pre-loaded with an example MALDI MSI dataset which is showcased in the associated preprint mentioned above. To load the example data (assuming that the package has been already loaded):

```{r load}
library(moleculaR)

data("processed-example-Data")

# to see the loaded objects
ls()

```
`msData` represents a centroided MALDI MSI dataset stored as a list of `MassPeaks` objects (see `?MALDIquant::MassPeaks` for more details), `fwhmObj` is an S3 object of type `fwhm` storing the calculated full width at half maximum (FWHM) information of `msData` (see `?moleculaR::fwhm` for more details), `mtspc` is a data frame storing the associated annotations file (≤0.2 FDR) which is downloaded directly from METASPACE (https://metaspace2020.eu) and `sldb` is a data frame storing the SwissLipids database filtered to only include the identifications outlined in `mtspc`.

To investigate FWHM as a function of m/z axis one could simply plot `fwhmObj`:

```{r plotFwhm}
plot(fwhmObj)
```

Or, to find the estimated FWHM at any given of m/z value one could simply pass `fwhmObj` to `GetFwhm` method:

```{r getFwhm}
# FWHM at m/z 400
getFwhm(fwhmObj, 400)
```
To speed up downstream analysis, _moleculaR_ relies on a sparse matrix representation of the MSI data. To this end, `msData` has to be first converted to an S3 object of type `moleculaR::sparseIntensityMatrix`:

```{r sparseMat}
#// create sparse matrix representation
spData <- createSparseMat(x = msData)
```


# Molecular Probability Maps (MPMs)

_moleculaR_ introduces the idea of molecular probability maps (MPMs) the main goal of which is to reduce the reliance on user's subjective opinion on the extent of spatial distribution of analytes within a given tissue section. Instead MPMs provide a user-unbiased statistical testing on the likelihood that a certain spatial intensity distribution has a significant abundance (i.e. analyte hotspot) or deficiency (i.e. analyte coldspot) within the tissue space. To illustrate this, consider as an example a peak-of-interest (POI) of 788.5447 m/z. 

```{r query}
# input by m/z value
queryMass         <- 788.5447 
```

_moleculaR_ provides `searchAnalyte` method to retrieve inensity values at a specific m/z with a mass-window dictated by the estimated FWHM at that same m/z value (see `?moleculaR::searchAnalyte` for more info). Moreover, `searchAnalyte` gives the user the possibility to choose which weighting method to choose, for example, setting the argument `wMethod="sum"`  will generate the so called "ion image" as all peaks appearing within the estimated mass-window will be summed up: 

```{r ionImage}
# compute the regular ion image - returns an AnalytePiontPattern
sppIonImage      <- searchAnalyte(m = queryMass, 
                                  fwhm = getFwhm(fwhmObj, queryMass), 
                                  spData = spData, 
                                  wMethod = "sum")


# compute a raster image of the sppIonImage 
ionImage        <- spatstat::pixellate(sppIonImage,
                          weights = sppIonImage$marks$intensity,
                          W = spatstat::as.mask(sppIonImage$window,
                                                dimyx=c(diff(sppIonImage$window$yrange),
                                                        diff(sppIonImage$window$xrange))),
                          padzero = FALSE)

```

Now to compute a FWHM-dependent Gaussian weighted analyte point pattern representation, set `wMethod="Gaussian"`. The `probMap` could then be called with the default parameters to calculate the corresponding MPM of the above POI (see `?probMap` for details) and the generic `plot` could be used on the result to plot a coposite detailed illustration (see `?plot.molProbMap` for details): 

```{r MPM, results='hide', fig.width=12, fig.height=16, warning=FALSE}
# compute spatial point pattern of the analyte
sppMoi          <- searchAnalyte(m = queryMass, 
                            fwhm = getFwhm(fwhmObj, queryMass), 
                            spData = spData,
                            wMethod = "Gaussian")




#// compute MPM - default parameters
probImg         <- probMap(sppMoi)

txt  <- paste0("m/z ", round(queryMass, 4), " ± ", round(getFwhm(fwhmObj, queryMass), 4))

#// plot everything together
par(cex.lab = 2, cex.main = 2, cex.axis = 1.5)
plot(probImg, what = "detailed", analyte = txt, ionImage = ionImage)


```

# Collective Projections Probability Maps (CPPMs)

Another concept introduced by _moleculaR_ is the collective projections probability maps (CPPMs) which, as the name implies, provides a framework for visualization of a set of analytes collectively in a single image space. This could be of interest when, for example, a user is interested in visualization a set of analaytes with a certain similarity (structure, functionality, etc.). For more information on how this is achieved, please refer to the associated preprint. 

## CPPMs - Lipid Classes

As _moleculaR_ is lipidome-focused in its current implementation, the test MSI dataset is screened against the internal instance of the SwissLipids database and is optionally verified by an externally provided lipidome annotation file downloaded from METASPACE for the given MSI dataset (pre-loaded for the current example). The `batchLipidSearch` method then is used to do this screening (for more details see `?batchLipidSearch`): 

```{r CPPMs, results='hide'}
cat("Batch lipid search is ongoing - this will take several minutes - \n")

searchList <- batchLipidSearch(spData = spData, fwhmObj = fwhmObj, sldb = sldb,
                               adduct = c("M+H", "M+Na", "M+K"),
                               numCores = 4L, verifiedMasses = as.numeric(mtspc$mz),
                               confirmedOnly = TRUE, verbose = TRUE)

```

The results is an S3 object `lipidSearchList` which contains the hits as `analytePointPattern` objects organized into a list of lipid classes (see `?lipidSearchList` for more details). To list all lipid classes which were detected (and confirmed by METASPACE; if `confirmedOnly=TRUE`):

```{r lipidClasses}
# whow all detected lipid classes
searchList$allClasses
```
Afterwards one could directly apply `probMap` method and produce a CPPM for all hit instances for a given lipid class : 

```{r CPPM.plot, results='hide', fig.width=12, fig.height=16, warning=FALSE}
# choose one lipid species
lipidClass <- "PA(x:x)"


# compute MPM - default parameters
probImg    <- probMap(searchList$hitsList[[lipidClass]], bwMethod = "scott", sqrtTansform = TRUE)

txt  <- paste0("m/z ", round(queryMass, 4), " ± ", round(getFwhm(fwhmObj, queryMass), 4))

#// plot everything together
par(cex.lab = 2, cex.main = 2, cex.axis = 1.5)
plot(probImg, what = "detailed", 
      analyte = paste0(lipidClass, " - n=", 
                       length(probImg$sppMoi$metaData$mzVals)))

```

Note that for CPPMs it is recommended to use square root transformation `sqrtTansform=TRUE` for the intensities to limit the impact of unequal ionization effeciency across analytes. It is also advisable to use `bwMethod="scott"` for computational effeciency. 

## CPPMs - Ion Milieus

To be able to generate custom CPPMs i.e. CPPMs projecting a specific set of analytes with user-chosen characterestics the `searchList` created by the `batchLipidSearch` method must be merged into a single `analytePointPattern`:

```{r CPPMs.combin, results='hide'}
# create a window of type 'spatstat::owin' 
spWin <- spatstat::as.polygonal(spatstat::owin(mask = spData$coordinates))

cat("combining all lyso-GPLs into one SPP object - a couple of minutes - \n")
lysoGplsSumSpp <- superImposeAnalytes(searchList$hitsList, 
                                      spWin = spWin)

```
Note that `lysoGplsSumSpp` represents all lipid hits of (lyso)GPLs. Then one could use `subsetAnalytes` to subset `lysoGplsSumSpp` according to any analyte characterestic of the `metaData` table i.e. 

```{r metadataCols}
# meta data table columns
colnames(lysoGplsSumSpp$metaData)
```
To this end, one could visualize for example all [M+K]+ adducts of detected (lyso)GPLs: 

```{r adducts,fig.width=12, fig.height=10}
# detected adducts
detectedAdducts <- unique(lysoGplsSumSpp$metaData$adduct) 

detectedAdducts


# subsetting
kspp            <- subsetAnalytes(lysoGplsSumSpp, adduct == "M+K")
# or Naspp      <- subsetAnalytes(lysoGplsSumSpp, adduct == "M+Na")
# or Hspp       <- subsetAnalytes(lysoGplsSumSpp, adduct == "M+H")

```

To apply CPPMs and plot the result for [M+K]+:

```{r ions.plot.K, results='hide', fig.width=12, fig.height=16, warning=FALSE}

# compute CPPM
probImg    = probMap(kspp, bwMethod = "scott", sqrtTansform = TRUE)

if(probImg$sppMoi$n > 50000) {
  cat("plotting ", format(probImg$sppMoi$n, big.mark = ","), " points - this takes time! \n")
}
par(cex.lab = 2, cex.main = 2, cex.axis = 1.5)

plot(probImg, what = "detailed", analyte = paste0("[M+k]+ of (lyso)GPLs - n=", length(probImg$sppMoi$metaData$mzVals)))



```


## CPPMs - Lipid Saturation

The same technique could applied to investigate lyso(GPLs) saturation (saturated, mono-unsaturated, di-unsaturated and poly-unsaturated) within one image space by subsetting based on the number of double-bonds of the lipid fatty acid chain. 

```{r subsetting.saturation}
detectedSaturation <- c("sat", "mono-unsat", "di-unsat", "poly-unsat")


# subsetting
satspp              <- subsetAnalytes(lysoGplsSumSpp, numDoubleBonds == 0)
# or monospp        <- subsetAnalytes(lysoGplsSumSpp, numDoubleBonds == 1)
# or dispp          <- subsetAnalytes(lysoGplsSumSpp, numDoubleBonds == 2)
# or polyspp        <- subsetAnalytes(lysoGplsSumSpp, numDoubleBonds > 2)

```

input for the specific saturation

```{r cppms.unsat.plot,results='hide', fig.width=12, fig.height=16, warning=FALSE}
# compute CPPM
probImg    = probMap(satspp, bwMethod = "scott", sqrtTansform = TRUE)

if(probImg$sppMoi$n > 50000) {
  cat("plotting ", format(probImg$sppMoi$n, big.mark = ","), " points - this takes time! \n")
}
par(cex.lab = 2, cex.main = 2, cex.axis = 1.5)
plot(probImg, what = "detailed", analyte = paste0("mono-unsat of ", "(lyso)GPLs", " - n=", length(probImg$sppMoi$metaData$mzVals)))

```

# Session Information

```{r}
sessionInfo()
```

