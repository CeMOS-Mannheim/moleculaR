---
title: "moleculaR: Spatial Probabilistic Mapping of Metabolites in Mass Spectrometry Imaging"
author: "Denis Abu Sammour & James-Lucas Cairns"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    number_sections: true
theme: cosmo
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

```

This is the Vignette for moleculaR.

# Introduction

## Accompanying data

For more info on how to properly include data into packages check [this page](https://r-pkgs.org/data.html).  

**data** subdirectroy contains a pre-processed and analysis-ready RData file, containing everything needed to run an example or web-hosted shiny app. This will be included on the Github (not Git-synced).

**inst/extdata/** subdirectroy contains: (this will be part of the package but not synced by Git)  
* two txt file holding the url of the imzml (and ibd) in metaspace.  
* one tsv file containing one single continuous (full) spectrum (used for the accompanying example data).   
* one tsv file cotaning filtered swiss lipids database (used internally).     
* one csv file containing metaspace annotations for the example datase (used for the accompanying example data).   
  
**data-external** subdirectroy contains: (this is only for development, not Git-synced and will be removed later)  
* two files; imzML and ibd, processed examplary MSI data.  
  
**data-shinyWebHosted** subdirectroy is meant to contain processed ready-to-analyze data preferrably in .RData envirobnment type. This would ideally work with a web-hosted shiny app and will load RData on start. Please check [this page](https://shiny.rstudio.com/articles/persistent-data-storage.html) and let me know if this is actually an option. If they do not allow for data hosting we could always fetch the Github::moleculaR/data/RData file by downloading it and loading it into the session.
  
## Package-app inputs/outputs

**[GUI Inputs]**    
**imzmlFile**     string-browse, path to a single centroided (i.e. processed) imzML file.  
**spectrFile**    string-browse, path to a single tsv file contianing a full continuous spectrum.  
*single analyte case*  
**queryMass**     numeric-insert, m/z value. 
**probMapMethod** method used to generate the molecular probability map method.  
*collective projections case*   
**mtspc**         string-browse, path to metaspace annotation file (.csv).  
**lipidSpecies**  string-dropdown, values = `searchList$allClasses`      


**[GUI Outputs]**  
**plot**          fwhm as a function of m/z, generated after loading the single spectrum.   
*single analyte case*
**image**         ion image of the `queryMass`.   
**image**         molecular probability map of the `queryMass`.   
  
*collective projections case - if metaspace annotation file is not supplied*  
**image**         collective probability map of all instances of the chosen `lipidSpecies`.  
  
*collective projections case - if metaspace annotation file is provided*  
**image**         collective probability map of confirmed instances of the chosen `lipidSpecies`.  
**console output** confirmed identifications.  





# Example workflow

## Load data 

```{r}

library(moleculaR)
######################
#### local input #####
######################

#// MSI data - either load a local file 
imzmlFile         = "pathToFile.imzML"                # <-- browse input-selected locally i.e. file will be 
                                                       # uploaded to the temp dir of R. 

imzmlFile         = file.path(getwd(), "data-external", "pos-XIII-82492-msi.imzML") # temporary, just to test this nb

#// read the file into R
msData            = readCentrData(path = imzmlFile)    # would be nice to console-notify when done reading


#// single spectrum -  load a local tsv file 
spectrFile        = "pathToFile.tsv"                  # <-- browse input-selected locally i.e. file will be 
                                                       # uploaded to the temp dir of R. 

spectrFile        = system.file("extdata", "pos-XIII-82492-singleSpectrum.tsv", package = "moleculaR", mustWork = TRUE)# temporary
msSpectr          = readSingleSpect(spectrFile) 


#// load the processed swisslipids db internally
pathTosldb        = system.file("extdata", "swisslipids-speciesOnly-sep2020.tsv", package = "moleculaR", mustWork = TRUE)
sldb              = loadSwissDB(pathTosldb)


#// load the metaspace annotations file - supplied by user
pathToMtspc       = "pathToFile.csv"                  # <-- browse input-selected locally
pathToMtspc        = system.file("extdata", "metaspace_annotations.csv", package = "moleculaR", mustWork = TRUE) # temporary
mtspc             = read.csv(file = pathToMtspc, skip = 2,header = TRUE, colClasses = "character")


```


## preprocessing of MS data

```{r}

#// estimate fwhm from msSpectr ----
fwhmFun           = estimateFwhm(s = msSpectr, plot = TRUE) # <-- this should be run directly after the spectrFile is 
                                                            # uploaded, a plot is generated


# bin peaks
# -- notify at start  --#
msData            =  MALDIquant::binPeaks(msData, 
                                           tolerance = fwhmFun(400)/400, #focusing on lipids 
                                           method = "relaxed")
# -- notify when done --#


# filter out peaks which occur in less than 1% of the time - the 
# built-in function of MALDIquant crashes for bigger datasets
# -- notify at start  --#
msData            = filterPeaks(x = msData, minFreq = 0.01)
# -- notify when done --#


# normalization 
# -- notify at start  --#
#msData            = foldChangeNorm(msData) <-- this is optional, no need for this
# -- notify when done --#


#// create spatial window 
spwin             = spatstat::as.polygonal(spatstat::owin(mask = as.data.frame(MALDIquant::coordinates(msData))))


#// create sparse matrix representation
spmat             = createSparseMat(x = msData)

# End of preproccessing
```





## Molecular Probability Maps (MPM)



```{r}
#// input by m/z value
queryMass         = 496.33972                                   # <-- input, numeric m/z value, use this as default value for exmaple
bwMethod          = "iterative"                                 # <-- input, c("iterative", "scott")

# NOTE: would be better to have two bwMethod inputs; one for one analyte case (defaults to "iterative") and one for 
# collective projection case (defaults to "scott").  


```


```{r fig.width=8}
#// output::ion image
s                 = MALDIquant::msiSlices(x = msData, center = queryMass, 
                                          tolerance = (fwhmFun(queryMass) / 2.355) * 3)

if(sum(s, na.rm = T) == 0){
      par(mfrow = c(1, 1))
      #// image without masking
      spatstat::plot.owin(spwin, 
                  main = paste0("No insances of m/z ", round(queryMass, 4), " were detected"), 
                  ylim = rev(range(spwin$y)), 
                  box = FALSE)
} else {
      
    MALDIquant::plotMsiSlice(x = s,  
                             colRamp = colorRamp(viridis::viridis_pal(option = "inferno")(100)), 
                             interpolate = F)
  
}
```

```{r fig.width=8}
#// output::molecular probability map
.uniqueMass       = as.numeric(spmat@Dimnames[[2]])


hits              = searchAnalyte(m = queryMass, 
                                  fwhm = fwhmFun(queryMass), 
                                  massAxis = .uniqueMass, 
                                  spData = spmat, 
                                  coords = MALDIquant::coordinates(msData))



#// check if hits is empty
# if(nrow(hits) == 0)
# {
#   
#   par(mfrow = c(1, 1))
#   #// image without masking
#   spatstat::plot.owin(spwin, 
#                   main = paste0("No insances of m/z ", round(queryMass, 4), " were detected"), 
#                   ylim = rev(range(spwin$y)), 
#                   box = FALSE)
#   
# } else {
#   
#   par(mfrow = c(1, 1))
# 
#   
#   #// create the spatial point pattern
#   hitsppp              = spatstat::ppp(x = hits$x,
#                                        y = hits$y,
#                                        window = spwin,
#                                        marks = hits[ , -c(1, 2)])
#   
#   
#   #// plotting
#   
#   probImg              = probMap(hitsppp, bwMethod = bwMethod)
#   
#   
#   spatstat::plot.im(probImg$denspp,
#                     main = paste0("m/z ", round(queryMass, 4), " +/- ", round((fwhmFun(queryMass) / 2.355) * 3, 4)),
#                   col = spatstat::colourmap(viridis::viridis_pal(option = "inferno")(100), range = range(probImg$denspp, na.rm = T)),
#                   ylim = rev(range(spwin$y)),
#                   box = FALSE)
#   spatstat::plot.im(probImg$nonHotspotMask, col = rgb(0,0,0,0.3), add = TRUE)
# }
```






## Collective Projection Maps (CPM)

The three different Collective Projection Maps (CPMs) that can be generted are: 

1. Lipid Classes
2. Ion Milleu
3. Lipid Saturation

### Lipid Classes

```{r fig.width=8}

#// filter sldb
Hidx = MALDIquant::match.closest(x = sldb$`Exact m/z of [M+H]+`, 
                                 table = sort(as.numeric(mtspc$mz)), 
                                 tolerance = fwhmFun(sldb$`Exact m/z of [M+H]+`))

Naidx = MALDIquant::match.closest(x = sldb$`Exact m/z of [M+Na]+`, 
                                 table = sort(as.numeric(mtspc$mz)), 
                                 tolerance = fwhmFun(sldb$`Exact m/z of [M+Na]+`))

kidx = MALDIquant::match.closest(x = sldb$`Exact m/z of [M+K]+`, 
                                 table = sort(as.numeric(mtspc$mz)), 
                                 tolerance = fwhmFun(sldb$`Exact m/z of [M+K]+`))



idxToKeep = c(which(!is.na(Hidx)), which(!is.na(Naidx)), which(!is.na(kidx)))

sldb = sldb[idxToKeep, ]

#// initialize the swisslipids database
searchList           = initLipidSearch(swissdb = sldb)

#// find peaks
.uniqueMass       = as.numeric(spmat@Dimnames[[2]])

for(lipidClass in names(searchList$lipidHits)){
  
searchList$lipidHits[[lipidClass]] = parallel::mclapply(X = seq(1, nrow(searchList$swissList[[lipidClass]])), 
                                                          mc.cores = 1, FUN = function(i) {
       
       
       df            = data.frame(x = integer(0), 
                            y = integer(0),
                            mass = numeric(0),
                            intensity = numeric(0), 
                            adduct = character(0), 
                            mode = character(0),
                            modeAdduct = character(0),
                            lipidID = character(0),
                            sumformula = character(0), 
                            fullName = character(0),
                            abbrev = character(0),
                            numDoubleBonds = integer(0),
                            stringsAsFactors = F)
       
       msCoordinates = MALDIquant::coordinates(msData)
       
                              
   
       
       #// protonated ----
       lipTmp        = searchList$swissList[[lipidClass]]$`Exact m/z of [M+H]+`[i]
       
              if(!is.na(lipTmp)) { # for example there is no protonated version of this lipid species


                       df     = rbind(df, 
                                      searchLipid(m = lipTmp, 
                                                  fwhm = fwhmFun(lipTmp), 
                                                  massAxis = .uniqueMass, 
                                                  spData = spmat, 
                                                  coords = msCoordinates,
                                                  mtspc = mtspc, # <--
                                                  confirmedOnly = TRUE,
                                                  adduct = "H1",  # <--
                                                  mode = "positive",  # <--
                                                  modeAdduct = "M+H",  # <--
                                                  lipidID = searchList$swissList[[lipidClass]]$`Lipid ID`[i], 
                                                  sumformula = searchList$swissList[[lipidClass]]$`Formula (pH7.3)`[i], 
                                                  abbrev = searchList$swissList[[lipidClass]]$`Abbreviation*`[i], 
                                                  numDoubleBonds = searchList$swissList[[lipidClass]]$numDoubleBond[i]))
                       
                      
  

              }
      
       
       #// Na+ adduct ----
       lipTmp               = searchList$swissList[[lipidClass]]$`Exact m/z of [M+Na]+`[i]
       
              if(!is.na(lipTmp)) { # for example there is no Na-adduct version


                       
                       df     = rbind(df, 
                                      searchLipid(m = lipTmp, 
                                                  fwhm = fwhmFun(lipTmp), 
                                                  massAxis = .uniqueMass, 
                                                  spData = spmat, 
                                                  coords = msCoordinates,
                                                  mtspc = mtspc, # <--
                                                  confirmedOnly = TRUE,
                                                  adduct = "Na1",  # <--
                                                  mode = "positive",  # <--
                                                  modeAdduct = "M+Na",  # <--
                                                  lipidID = searchList$swissList[[lipidClass]]$`Lipid ID`[i], 
                                                  sumformula = searchList$swissList[[lipidClass]]$`Formula (pH7.3)`[i], 
                                                  abbrev = searchList$swissList[[lipidClass]]$`Abbreviation*`[i], 
                                                  numDoubleBonds = searchList$swissList[[lipidClass]]$numDoubleBond[i]))
                       

  

              }

       
       #// K+ adduct ----
       lipTmp        = searchList$swissList[[lipidClass]]$`Exact m/z of [M+K]+`[i]
       
              if(!is.na(lipTmp)) { # for example there is no Na-adduct version

                       df     = rbind(df, 
                                      searchLipid(m = lipTmp, 
                                                  fwhm = fwhmFun(lipTmp), 
                                                  massAxis = .uniqueMass, 
                                                  spData = spmat, 
                                                  coords = msCoordinates,
                                                  mtspc = mtspc, # <--
                                                  confirmedOnly = TRUE,
                                                  adduct = "K1",  # <--
                                                  mode = "positive",  # <--
                                                  modeAdduct = "M+K",  # <--
                                                  lipidID = searchList$swissList[[lipidClass]]$`Lipid ID`[i], 
                                                  sumformula = searchList$swissList[[lipidClass]]$`Formula (pH7.3)`[i], 
                                                  abbrev = searchList$swissList[[lipidClass]]$`Abbreviation*`[i], 
                                                  numDoubleBonds = searchList$swissList[[lipidClass]]$numDoubleBond[i]))
                                                   
 
                     

              }
      
       
       return(df)
       })


#// merge
searchList$lipidHits[[lipidClass]] = do.call("rbind", searchList$lipidHits[[lipidClass]])
}
```


plotting all detections of a chosen lipid class

```{r fig.width=12, fig.height=10}
#// choose one lipid species
lipidClass         = "PA(x:x)"                        # <-- Input, selection from drop-down, values = searchList$allClasses
bwMethod          = "scott"                           # fix that 



if(is.null(searchList$lipidHits[[lipidClass]])) {
  
  
  
   par(mfrow = c(1, 1))

  #// empty window
  spatstat::plot.owin(spwin,
                  main = paste0("No insances of ", lipidClass, " were detected"),
                  ylim = rev(range(spwin$y)),
                  box = FALSE)
  
  
} else {


  sppCpm              = spatstat::ppp(x = searchList$lipidHits[[lipidClass]]$x,
                                     y = searchList$lipidHits[[lipidClass]]$y,
                                     window = spwin,
                                     marks = searchList$lipidHits[[lipidClass]][ , -c(1, 2)], 
                                     checkdup = FALSE)

  sppCpm              = spatstat::as.ppp(sppCpm)

  probImg              = probMap(sppCpm, bwMethod = "scott", sqrtTansform = TRUE) # fixed arguments
  
  

  
  par(mfrow = c(3, 2))

# _________________________________________________ part one: CSR

colfun        = spatstat::colourmap(col = spatstat::to.transparent((viridis::viridis_pal(option = "inferno")(100)), 0.7), 
                                      range = range(probImg$csrMoi$marks$intensity))

spatstat::plot.ppp(probImg$csrMoi, use.marks = TRUE, which.marks = "intensity", 
                   ylim = rev(spwin$yrange), 
                   main = paste0("CSR of ", lipidClass),
                   symap = spatstat::symbolmap(pch = 19, 
                                   cols = colfun,
                                   size = 0.4,
                                   range = range(probImg$csrMoi$marks$intensity))) # colors according to intensity

# _________________________________________________ part two: SPP

colfun        = spatstat::colourmap(col = spatstat::to.transparent((viridis::viridis_pal(option = "inferno")(100)), 0.7), 
                                      range = range(probImg$sppMoi$marks$intensity))

spatstat::plot.ppp(probImg$sppMoi, use.marks = TRUE, which.marks = "intensity", 
                   ylim = rev(spwin$yrange), 
                   main = paste0("SPP of ", lipidClass),
                   symap = spatstat::symbolmap(pch = 19, 
                                   cols = colfun,
                                   size = 0.4,
                                   range = range(probImg$sppMoi$marks$intensity))) # colors according to intensity



# _________________________________________________ part three: rho of csr

spatstat::plot.im(probImg$rhoCsr,
                  main = expression(paste(rho["CSR"], "(x,y)")),
                col = spatstat::colourmap(viridis::viridis_pal(option = "inferno")(100), range = range(probImg$rhoCs, na.rm = T)),
                ylim = rev(range(spwin$y)),
                box = FALSE)


# _________________________________________________ part four: rho of MOI

spatstat::plot.im(probImg$rhoMoi,
                  main = expression(paste(rho["MOIs"], "(x,y)")),
                col = spatstat::colourmap(viridis::viridis_pal(option = "inferno")(100), range = range(probImg$rhoMoi, na.rm = T)),
                ylim = rev(range(spwin$y)),
                box = FALSE)





# _________________________________________________ part five : CPM

spatstat::plot.im(probImg$rhoMoi,
                  main = paste0("CPM of ", lipidClass),
                  col = spatstat::colourmap(viridis::viridis_pal(option = "inferno")(100), range = range(probImg$rhoMoi, na.rm = T)),
                  ylim = rev(range(spwin$y)),
                  box = FALSE)
  
spatstat::plot.owin(probImg$hotspotpp$window, col = rgb(1,1,1,0.0), border = "white", lwd = 5,  add = TRUE)
spatstat::plot.owin(probImg$hotspotpp$window, col = rgb(1,1,1,0.0), border = "red", lwd = 2.5, lty = "dashed",add = TRUE)

spatstat::plot.owin(probImg$coldspotpp$window, col = rgb(1,1,1,0.0), border = "white", lwd = 5,  add = TRUE)
spatstat::plot.owin(probImg$coldspotpp$window, col = rgb(1,1,1,0.0), border = "blue", lwd = 2.5, lty = "dashed",add = TRUE)

legend("bottom", legend = c("Analyte Hotspot", "Analyte Coldspot"), lty = c("dashed"), 
       col = c("red", "blue"), bty = "n", horiz = TRUE)


}


```





### Ion Milieu

```{r fig.width=12, fig.height=10}
hitsList            = setNames(vector("list", 4), c("all", "M+K", "M+Na", "M+H"))

ionAdduct           = "" # input, dropdown



hitsList[["all"]]   = do.call("rbind", searchList$lipidHits[c("PC(x:x)",  
                                                        "PE(x:x)", 
                                                        "PI(x:x)",
                                                        "PS(x:x)", 
                                                        "LPC(x:x)",  
                                                        "LPE(x:x)", 
                                                        "LPI(x:x)",
                                                        "LPS(x:x)")])


#hitsList[["all"]]   = hitsList[["all"]][hitsList[["all"]]$confirmed == TRUE, ]

hitsList[["all"]]   = spatstat::ppp(x = hitsList[["all"]]$x,
                                   y = hitsList[["all"]]$y,
                                   window = spwin,
                                   marks = hitsList[["all"]][ , -c(1, 2)], 
                                   checkdup = FALSE)

hitsList[["all"]]   = spatstat::as.ppp(hitsList[["all"]])

hitsList[["M+K"]]     = spatstat::subset.ppp(hitsList[["all"]], modeAdduct == "M+K")
hitsList[["M+Na"]]    = spatstat::subset.ppp(hitsList[["all"]], modeAdduct == "M+Na")
hitsList[["M+H"]]     = spatstat::subset.ppp(hitsList[["all"]], modeAdduct == "M+H")

lipidSpecies         = "alkali-(lyso)GPLs"


```

input for the specific adduct

```{r fig.width=12, fig.height=10}
      
igroup              = "M+K" # <- input, dropdown


if(hitsList[[igroup]]$n == 0) {
  
  
  
   par(mfrow = c(1, 1))

  #// empty window
  spatstat::plot.owin(spwin,
                  main = paste0("No insances of ", igroup, " were detected"),
                  ylim = rev(range(spwin$y)),
                  box = FALSE)
  
  
} else {
  
probImg    = probMap(hitsList[[igroup]], bwMethod = "scott", sqrtTansform = TRUE)




par(mfrow = c(3, 2))

# _________________________________________________ part one: CSR

colfun        = spatstat::colourmap(col = spatstat::to.transparent((viridis::viridis_pal(option = "inferno")(100)), 0.7), 
                                      range = range(probImg$csrMoi$marks$intensity))

spatstat::plot.ppp(probImg$csrMoi, use.marks = TRUE, which.marks = "intensity", 
                   ylim = rev(spwin$yrange), 
                   #cols = viridis::viridis_pal(option = "inferno")(100), 
                   #markscale = 0.000004,
                   #zap = 0.0,
                   #chars = 21,
                   main = paste0("CSR of ", igroup),
                   symap = spatstat::symbolmap(pch = 19, 
                                   cols = colfun,
                                   size = 0.4,
                                   range = range(probImg$csrMoi$marks$intensity))) # colors according to intensity

# _________________________________________________ part two: SPP

colfun        = spatstat::colourmap(col = spatstat::to.transparent((viridis::viridis_pal(option = "inferno")(100)), 0.7), 
                                      range = range(probImg$sppMoi$marks$intensity))

spatstat::plot.ppp(probImg$sppMoi, use.marks = TRUE, which.marks = "intensity", 
                   ylim = rev(spwin$yrange), 
                   #cols = viridis::viridis_pal(option = "inferno")(100), 
                   #markscale = 0.000004,
                   #zap = 0.0,
                   #chars = 21,
                   main = paste0("SPP of ", igroup),
                   symap = spatstat::symbolmap(pch = 19, 
                                   cols = colfun,
                                   size = 0.4,
                                   range = range(probImg$sppMoi$marks$intensity))) # colors according to intensity



# _________________________________________________ part three: rho of csr

spatstat::plot.im(probImg$rhoCsr,
                  main = expression(paste(rho["CSR"], "(x,y)")),
                col = spatstat::colourmap(viridis::viridis_pal(option = "inferno")(100), range = range(probImg$rhoCs, na.rm = T)),
                ylim = rev(range(spwin$y)),
                box = FALSE)


# _________________________________________________ part four: rho of MOI

spatstat::plot.im(probImg$rhoMoi,
                  main = expression(paste(rho["MOIs"], "(x,y)")),
                col = spatstat::colourmap(viridis::viridis_pal(option = "inferno")(100), range = range(probImg$rhoMoi, na.rm = T)),
                ylim = rev(range(spwin$y)),
                box = FALSE)





# _________________________________________________ part five : CPM

spatstat::plot.im(probImg$rhoMoi,
                  main = paste0("CPM of ", igroup),
                  col = spatstat::colourmap(viridis::viridis_pal(option = "inferno")(100), range = range(probImg$rhoMoi, na.rm = T)),
                  ylim = rev(range(spwin$y)),
                  box = FALSE)
  
spatstat::plot.owin(probImg$hotspotpp$window, col = rgb(1,1,1,0.0), border = "white", lwd = 5,  add = TRUE)
spatstat::plot.owin(probImg$hotspotpp$window, col = rgb(1,1,1,0.0), border = "red", lwd = 2.5, lty = "dashed",add = TRUE)

spatstat::plot.owin(probImg$coldspotpp$window, col = rgb(1,1,1,0.0), border = "white", lwd = 5,  add = TRUE)
spatstat::plot.owin(probImg$coldspotpp$window, col = rgb(1,1,1,0.0), border = "blue", lwd = 2.5, lty = "dashed",add = TRUE)

legend("bottom", legend = c("Analyte Hotspot", "Analyte Coldspot"), lty = c("dashed"), 
       col = c("red", "blue"), bty = "n", horiz = TRUE)

}
```






### Lipid Saturation

```{r fig.width=12, fig.height=10}
hitsList            = setNames(vector("list", 5), c("all", "sat.", "mono.", "di.", "poly."))



hitsList[["all"]]   = do.call("rbind", searchList$lipidHits[c("PC(x:x)",  
                                                        "PE(x:x)", 
                                                        "PI(x:x)",
                                                        "PS(x:x)", 
                                                        "LPC(x:x)",  
                                                        "LPE(x:x)", 
                                                        "LPI(x:x)",
                                                        "LPS(x:x)")])


hitsList[["all"]]   = spatstat::ppp(x = hitsList[["all"]]$x,
                                   y = hitsList[["all"]]$y,
                                   window = spwin,
                                   marks = hitsList[["all"]][ , -c(1, 2)], 
                                   checkdup = FALSE)

hitsList[["all"]]   = spatstat::as.ppp(hitsList[["all"]])

hitsList[["sat."]]  = spatstat::subset.ppp(hitsList[["all"]], numDoubleBonds == 0L)
hitsList[["mono."]]  = spatstat::subset.ppp(hitsList[["all"]], numDoubleBonds == 1L)
hitsList[["di."]]  = spatstat::subset.ppp(hitsList[["all"]], numDoubleBonds == 2L)
hitsList[["poly."]]  = spatstat::subset.ppp(hitsList[["all"]], numDoubleBonds > 2L)

lipidSpecies         = "satrtn-(lyso)GPLs"



```

input for the specific adduct

```{r fig.width=12, fig.height=10}
      
igroup              = "mono." # <- input, dropdown


if(hitsList[[igroup]]$n == 0) {
  
  
  
   par(mfrow = c(1, 1))

  #// empty window
  spatstat::plot.owin(spwin,
                  main = paste0("No insances of ", igroup, " were detected"),
                  ylim = rev(range(spwin$y)),
                  box = FALSE)
  
  
} else {
  
probImg    = probMap(hitsList[[igroup]], bwMethod = "scott", sqrtTansform = TRUE)



  par(mfrow = c(3, 2))

# _________________________________________________ part one: CSR

colfun        = spatstat::colourmap(col = spatstat::to.transparent((viridis::viridis_pal(option = "inferno")(100)), 0.7), 
                                      range = range(probImg$csrMoi$marks$intensity))

spatstat::plot.ppp(probImg$csrMoi, use.marks = TRUE, which.marks = "intensity", 
                   ylim = rev(spwin$yrange), 
                   #cols = viridis::viridis_pal(option = "inferno")(100), 
                   #markscale = 0.000004,
                   #zap = 0.0,
                   #chars = 21,
                   main = paste0("CSR of ", igroup),
                   symap = spatstat::symbolmap(pch = 19, 
                                   cols = colfun,
                                   size = 0.4,
                                   range = range(probImg$csrMoi$marks$intensity))) # colors according to intensity

# _________________________________________________ part two: SPP

colfun        = spatstat::colourmap(col = spatstat::to.transparent((viridis::viridis_pal(option = "inferno")(100)), 0.7), 
                                      range = range(probImg$sppMoi$marks$intensity))

spatstat::plot.ppp(probImg$sppMoi, use.marks = TRUE, which.marks = "intensity", 
                   ylim = rev(spwin$yrange), 
                   #cols = viridis::viridis_pal(option = "inferno")(100), 
                   #markscale = 0.000004,
                   #zap = 0.0,
                   #chars = 21,
                   main = paste0("SPP of ", igroup),
                   symap = spatstat::symbolmap(pch = 19, 
                                   cols = colfun,
                                   size = 0.4,
                                   range = range(probImg$sppMoi$marks$intensity))) # colors according to intensity



# _________________________________________________ part three: rho of csr

spatstat::plot.im(probImg$rhoCsr,
                  main = expression(paste(rho["CSR"], "(x,y)")),
                col = spatstat::colourmap(viridis::viridis_pal(option = "inferno")(100), range = range(probImg$rhoCs, na.rm = T)),
                ylim = rev(range(spwin$y)),
                box = FALSE)


# _________________________________________________ part four: rho of MOI

spatstat::plot.im(probImg$rhoMoi,
                  main = expression(paste(rho["MOIs"], "(x,y)")),
                col = spatstat::colourmap(viridis::viridis_pal(option = "inferno")(100), range = range(probImg$rhoMoi, na.rm = T)),
                ylim = rev(range(spwin$y)),
                box = FALSE)





# _________________________________________________ part five : CPM

spatstat::plot.im(probImg$rhoMoi,
                  main = paste0("CPM of ", igroup),
                  col = spatstat::colourmap(viridis::viridis_pal(option = "inferno")(100), range = range(probImg$rhoMoi, na.rm = T)),
                  ylim = rev(range(spwin$y)),
                  box = FALSE)
  
spatstat::plot.owin(probImg$hotspotpp$window, col = rgb(1,1,1,0.0), border = "white", lwd = 5,  add = TRUE)
spatstat::plot.owin(probImg$hotspotpp$window, col = rgb(1,1,1,0.0), border = "red", lwd = 2.5, lty = "dashed",add = TRUE)

spatstat::plot.owin(probImg$coldspotpp$window, col = rgb(1,1,1,0.0), border = "white", lwd = 5,  add = TRUE)
spatstat::plot.owin(probImg$coldspotpp$window, col = rgb(1,1,1,0.0), border = "blue", lwd = 2.5, lty = "dashed",add = TRUE)

legend("bottom", legend = c("Analyte Hotspot", "Analyte Coldspot"), lty = c("dashed"), 
       col = c("red", "blue"), bty = "n", horiz = TRUE)
}

```







# Shiny App Usage

## Loading the Data & Preprocessing

This step just applies to the package-app.R, since the example-app.R skips this step of Loading & Preprocessing Data for demonstration purposes.

1. The first step using the shiny package-app, would be to upload you own data. To do this click on imzML & ibd File and navigate to the directory containing the files you want to upload. Then select both imzML- and ibd-Files and upload them.
2. Press Spectrum .tsv File and upload your Spectrum file .tsv format
3. Press Metaspace.csv File and upload your Metspace file in .csv format


![Loading the Data](vignette/package_app_load.PNG)

After successfully loading the data the message "Upload complete" should appear.

![Data Loaded](vignette/package_app_loaded.PNG)

When all files are fully loaded you can proceed and use the Peaks FWHM Estimation. To do this press Initialize as shown in the figure below.

![Peaks FWHM Estimation](vignette/fwhm_esti.PNG)

A progress bar will appear at the bottom right of the app.

![Progress Bar](vignette/progressbar.PNG)

When the data has been processed and FWHM has been estimated, a plot will appear showing the approximation.

![FWHM Estimation Completed](vignette/fwhm_loaded.PNG){width=70%}



## Molecular Probability Maps (MPM)

When loading Molecular Probability Maps (MPM), one can enter an exact mass. By default the closest m/z-value found in the dataset will be chosen. If you are looking for an exact mass, deactivate the checkbox shown in the figure below.

![Closest m/z in Dataset](vignette/closest mz.PNG)

After entering the desired mass press "Generate Plot" and wait until the plots are generated. 

![Molecular Probability Maps (MPM)](vignette/mmp_generated.PNG){width=70%}


## Collective Projection Maps (CPM)

The three different Collective Projection Maps (CPMs) that can be generted are: 

1. Lipid Classes
2. Ion Milleu
3. Lipid Saturation

### Lipid Classes

For Lipid Class generation one can choose a lipid from the dropdown menu before pressing "Generate Plot". 

![Lipid Classes Generation](vignette/cpm lipid classes generate.PNG)

After the generation is completed,  plot similar to the one below is displayed.

![Lipid Classes Output](vignette/cpm lipid classes generated.PNG){width=70%}



### Ion Milleu

For Ion Milleu generation one can choose between ```all, M+K, M+Na and M+H``` from the dropdown menu before pressing "Generate Plot". 

![Ion Milleu Generation](vignette/cpm ion generate.PNG)

After the generation is completed,  plot similar to the one below is displayed.

![Ion Milleu Output](vignette/cpm ion generated.PNG){width=70%}


### Lipid Saturation

For Lipid Saturation generation one can choose between ```all, sat., mono., di. and poly.``` from the dropdown menu before pressing "Generate Plot". 

![Lipid Saturation Generation](vignette/cpm lipid sat generate.PNG)

After the generation is completed,  plot similar to the one below is displayed.

![Lipid Saturation Output](vignette/cpm lipid sat generated.PNG){width=70%}



## Spatial Numeric Manipulation Maps



