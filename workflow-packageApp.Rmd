---
title: "example workflow"
author: "Denis Abu Sammour"
output:
  html_notebook:
    fig_height: 10
    fig_width: 15
  html_document:
    df_print: paged
    code_folding: hide
editor_options:
  chunk_output_type: inline
---

This notebook is used as blueprint for the shiny app development and dedicated vignettes. 

## Accompanying data

For more info on how to properly include data into packages check [this page](https://r-pkgs.org/data.html).  

**data** subdirectroy contains a pre-processed and analysis-ready RData file, containing everything needed to run an example or web-hosted shiny app. This will be included on the Github (not Git-synced).

**inst/extdata/** subdirectroy contains: (this will be part of the package but not synced by Git)  
* two txt file holding the url of the imzml (and ibd) in metaspace.  
* one tsv file containing one single continuous (full) spectrum (used for the accompanying example data).   
* one tsv file cotaning filtered swiss lipids database (used internally).     
* one csv file containing metaspace annotations for the example datase (used for the accompanying example data).   
  
**data-external** subdirectroy contains: (this is only for development, not Git-synced and will be removed later)  
* two files; imzML and ibd, processed examplary MSI data.  
  
**data-shinyWebHosted** subdirectroy is meant to contain processed ready-to-analyze data preferrably in .RData envirobnment type. This would ideally work with a web-hosted shiny app and will load RData on start. Please check [this page](https://shiny.rstudio.com/articles/persistent-data-storage.html) and let me know if this is actually an option. If they do not allow for data hosting we could always fetch the Github::moleculaR/data/RData file by downloading it and loading it into the session.
  
## Package-app inputs/outputs

**[GUI Inputs]**    
**imzmlFile**     string-browse, path to a single centroided (i.e. processed) imzML file.  
**spectrFile**    string-browse, path to a single tsv file contianing a full continuous spectrum.  
*single analyte case*  
**queryMass**     numeric-insert, m/z value. 
**probMapMethod** method used to generate the molecular probability map method.  
*collective projections case*   
**mtspc**         string-browse, path to metaspace annotation file (.csv).  
**lipidSpecies**  string-dropdown, values = `searchList$allClasses`      


**[GUI Outputs]**  
**plot**          fwhm as a function of m/z, generated after loading the single spectrum.   
*single analyte case*
**image**         ion image of the `queryMass`.   
**image**         molecular probability map of the `queryMass`.   
  
*collective projections case - if metaspace annotation file is not supplied*  
**image**         collective probability map of all instances of the chosen `lipidSpecies`.  
  
*collective projections case - if metaspace annotation file is provided*  
**image**         collective probability map of confirmed instances of the chosen `lipidSpecies`.  
**console output** confirmed identifications.  




## Workflow for package-app 


### Load data 

```{r}

library(moleculaR)
######################
#### local input #####
######################

#// MSI data - either load a local file 
imzmlFile         = "pathToFile.imzML"                # <-- browse input-selected locally i.e. file will be 
                                                       # uploaded to the temp dir of R. 

imzmlFile         = file.path(getwd(), "data-external", "pos-XIII-82492-msi.imzML") # temporary, just to test this nb

#// read the file into R
msData            = readCentrData(path = imzmlFile)    # would be nice to console-notify when done reading


#// single spectrum -  load a local tsv file 
spectrFile        = "pathToFile.tsv"                  # <-- browse input-selected locally i.e. file will be 
                                                       # uploaded to the temp dir of R. 

spectrFile        = system.file("extdata", "pos-XIII-82492-singleSpectrum.tsv", package = "moleculaR", mustWork = TRUE)# temporary
msSpectr          = readSingleSpect(spectrFile) 


#// load the processed swisslipids db internally
pathTosldb        = system.file("extdata", "swisslipids-speciesOnly-sep2020.tsv", package = "moleculaR", mustWork = TRUE)
sldb              = loadSwissDB(pathTosldb)


#// load the metaspace annotations file - supplied by user
pathToMtspc       = "pathToFile.csv"                  # <-- browse input-selected locally
pathToMtspc        = system.file("extdata", "metaspace_annotations.csv", package = "moleculaR", mustWork = TRUE) # temporary
mtspc             = read.csv(file = pathToMtspc, skip = 2,header = TRUE, colClasses = "character")


```


### preprocessing of MS data

```{r}

#// estimate fwhm from msSpectr ----
fwhmFun           = estimateFwhm(s = msSpectr, plot = TRUE) # <-- this should be run directly after the spectrFile is 
                                                            # uploaded, a plot is generated


# bin peaks
# -- notify at start  --#
msData            =  MALDIquant::binPeaks(msData, 
                                           tolerance = fwhmFun(400)/400, #focusing on lipids 
                                           method = "relaxed")
# -- notify when done --#


# filter out peaks which occur in less than 1% of the time - the 
# built-in function of MALDIquant crashes for bigger datasets
# -- notify at start  --#
msData            = filterPeaks(x = msData, minFreq = 0.01)
# -- notify when done --#


# normalization 
# -- notify at start  --#
#msData            = foldChangeNorm(msData) <-- this is optional, no need for this
# -- notify when done --#


#// create spatial window 
spwin             = spatstat::as.polygonal(spatstat::owin(mask = as.data.frame(MALDIquant::coordinates(msData))))


#// create sparse matrix representation
spmat             = createSparseMat(x = msData)

# End of preproccessing
```



## one analyte at a time - m/z case


```{r}
#// input by m/z value
queryMass         = 496.33972                                   # <-- input, numeric m/z value, use this as default value for exmaple
bwMethod          = "iterative"                                 # <-- input, c("iterative", "scott")

# NOTE: would be better to have two bwMethod inputs; one for one analyte case (defaults to "iterative") and one for 
# collective projection case (defaults to "scott").  


```


```{r fig.width=8}
#// output::ion image
s                 = MALDIquant::msiSlices(x = msData, center = queryMass, 
                                          tolerance = (fwhmFun(queryMass) / 2.355) * 3)

if(sum(s, na.rm = T) == 0){
      par(mfrow = c(1, 1))
      #// image without masking
      spatstat::plot.owin(spwin, 
                  main = paste0("No insances of m/z ", round(queryMass, 4), " were detected"), 
                  ylim = rev(range(spwin$y)), 
                  box = FALSE)
} else {
      
    MALDIquant::plotMsiSlice(x = s,  
                             colRamp = colorRamp(viridis::viridis_pal(option = "inferno")(100)), 
                             interpolate = F)
  
}
```

```{r fig.width=8}
#// output::molecular probability map
.uniqueMass       = as.numeric(spmat@Dimnames[[2]])


hits              = searchAnalyte(m = queryMass, 
                                  fwhm = fwhmFun(queryMass), 
                                  massAxis = .uniqueMass, 
                                  spData = spmat, 
                                  coords = MALDIquant::coordinates(msData))



#// check if hits is empty
if(nrow(hits) == 0)
{
  
  par(mfrow = c(1, 1))
  #// image without masking
  spatstat::plot.owin(spwin, 
                  main = paste0("No insances of m/z ", round(queryMass, 4), " were detected"), 
                  ylim = rev(range(spwin$y)), 
                  box = FALSE)
  
} else {
  
  par(mfrow = c(1, 1))

  
  #// create the spatial point pattern
  hitsppp              = spatstat::ppp(x = hits$x,
                                       y = hits$y,
                                       window = spwin,
                                       marks = hits[ , -c(1, 2)])
  
  
  #// plotting
  
  probImg              = probMap(hitsppp, win = spwin, bwMethod = bwMethod)
  
  
  spatstat::plot.im(probImg$denspp,
                    main = paste0("m/z ", round(queryMass, 4), " +/- ", round((fwhmFun(queryMass) / 2.355) * 3, 4)),
                  col = spatstat::colourmap(viridis::viridis_pal(option = "inferno")(100), range = range(probImg$denspp, na.rm = T)),
                  ylim = rev(range(spwin$y)),
                  box = FALSE)
  spatstat::plot.im(probImg$nonHotspotMask, col = rgb(0,0,0,0.3), add = TRUE)
  
    
  
  
  
}
```


## Collective projection case - lipid classes

```{r fig.width=8}
#// load swiss lipid database - 
# -- loaded -- 

#// initialize the swisslipids database
searchList           = initLipidSearch(swissdb = sldb)


#// choose one lipid species
lipidClass         = "PI(x:x)"                        # <-- Input, selection from drop-down, values = searchList$allClasses
bwMethod          = "scott"                           # <-- input, c("iterative", "scott")
# NOTE: would be better to have two bwMethod inputs; one for one analyte case (defaults to "iterative") and one for 
# collective projection case (defaults to "scott").  



#// load metaspace identification list
# check if metaspace identification file has been supplied by the user, if not then only show all-detections. 

if(!exists("mtspc")) { # this should be something like input$mtspc .. 
      mtspc = NA
} 


#// find peaks
.uniqueMass       = as.numeric(spmat@Dimnames[[2]])



searchList$lipidHits[[lipidClass]] = parallel::mclapply(X = seq(1, nrow(searchList$swissList[[lipidClass]])), 
                                                          mc.cores = 5, FUN = function(i) {
       
       
       df            = data.frame(x = integer(0), 
                            y = integer(0),
                            mass = numeric(0),
                            intensity = numeric(0), 
                            adduct = character(0), 
                            mode = character(0),
                            modeAdduct = character(0),
                            lipidID = character(0),
                            sumformula = character(0), 
                            fullName = character(0),
                            abbrev = character(0),
                            numDoubleBonds = integer(0),
                            stringsAsFactors = F)
       
       msCoordinates = MALDIquant::coordinates(msData)
       
       #// protonated ----
       lipTmp        = searchList$swissList[[lipidClass]]$`Exact m/z of [M+H]+`[i]
       
              if(!is.na(lipTmp)) { # for example there is no protonated version of this lipid species


                       df     = rbind(df, 
                                      searchLipid(m = lipTmp, 
                                                  fwhm = fwhmFun(lipTmp), 
                                                  massAxis = .uniqueMass, 
                                                  spData = spmat, 
                                                  coords = msCoordinates,
                                                  mtspc = mtspc, # <--
                                                  adduct = "H1",  # <--
                                                  mode = "positive",  # <--
                                                  modeAdduct = "M+H",  # <--
                                                  lipidID = searchList$swissList[[lipidClass]]$`Lipid ID`[i], 
                                                  sumformula = searchList$swissList[[lipidClass]]$`Formula (pH7.3)`[i], 
                                                  abbrev = searchList$swissList[[lipidClass]]$`Abbreviation*`[i], 
                                                  numDoubleBonds = searchList$swissList[[lipidClass]]$numDoubleBond[i]))
  

              }
      
       
       #// Na+ adduct ----
       lipTmp               = searchList$swissList[[lipidClass]]$`Exact m/z of [M+Na]+`[i]
       
              if(!is.na(lipTmp)) { # for example there is no Na-adduct version


                       
                       df     = rbind(df, 
                                      searchLipid(m = lipTmp, 
                                                  fwhm = fwhmFun(lipTmp), 
                                                  massAxis = .uniqueMass, 
                                                  spData = spmat, 
                                                  coords = msCoordinates,
                                                  mtspc = mtspc, # <--
                                                  adduct = "Na1",  # <--
                                                  mode = "positive",  # <--
                                                  modeAdduct = "M+Na",  # <--
                                                  lipidID = searchList$swissList[[lipidClass]]$`Lipid ID`[i], 
                                                  sumformula = searchList$swissList[[lipidClass]]$`Formula (pH7.3)`[i], 
                                                  abbrev = searchList$swissList[[lipidClass]]$`Abbreviation*`[i], 
                                                  numDoubleBonds = searchList$swissList[[lipidClass]]$numDoubleBond[i]))
                       

  

              }

       
       #// K+ adduct ----
       lipTmp        = searchList$swissList[[lipidClass]]$`Exact m/z of [M+K]+`[i]
       
              if(!is.na(lipTmp)) { # for example there is no Na-adduct version

                       df     = rbind(df, 
                                      searchLipid(m = lipTmp, 
                                                  fwhm = fwhmFun(lipTmp), 
                                                  massAxis = .uniqueMass, 
                                                  spData = spmat, 
                                                  coords = msCoordinates,
                                                  mtspc = mtspc, # <--
                                                  adduct = "K1",  # <--
                                                  mode = "positive",  # <--
                                                  modeAdduct = "M+K",  # <--
                                                  lipidID = searchList$swissList[[lipidClass]]$`Lipid ID`[i], 
                                                  sumformula = searchList$swissList[[lipidClass]]$`Formula (pH7.3)`[i], 
                                                  abbrev = searchList$swissList[[lipidClass]]$`Abbreviation*`[i], 
                                                  numDoubleBonds = searchList$swissList[[lipidClass]]$numDoubleBond[i]))
                                                   
 
                     

              }
      
       
       return(df)
       })


#// merge
searchList$lipidHits[[lipidClass]] = do.call("rbind", searchList$lipidHits[[lipidClass]])


#// added check 
if(nrow(searchList$lipidHits[[lipidClass]]) == 0) {
  
  par(mfrow = c(1, 1))
  
  #// empty window
  spatstat::plot.owin(spwin, 
                  main = paste0("No insances of ", lipidClass, " were detected"), 
                  ylim = rev(range(spwin$y)), 
                  box = FALSE)
  
  detectionsExist = FALSE
  
  
} else {
  detectionsExist = TRUE
}

#// create the spatial point pattern
if(detectionsExist){
  
  hitsppp              = spatstat::ppp(x = searchList$lipidHits[[lipidClass]]$x,
                                     y = searchList$lipidHits[[lipidClass]]$y,
                                     window = spwin,
                                     marks = searchList$lipidHits[[lipidClass]][ , -c(1, 2)])

}


if(detectionsExist) {
  
  tmpm                 = unique(searchList$lipidHits[[lipidClass]]$mass) # stores unique detected masses
tmpc                 = unique(searchList$lipidHits[[lipidClass]][c("mass", "confirmed", "modeAdduct")])

cat("\nConfirmed(metaspace) | Detected(in dataset) | Total(swisslipids) = ", 
   length(which(tmpc$confirmed)),
   " | ",
   length(tmpm),
   " | ",
   nrow(searchList$swissList[[lipidClass]]) * 4, # because each entry has 4 different adducts
   "\n")
cat(" M+H  detected = ", length(which(tmpc$modeAdduct == "M+H") ),
   " | ",
   "M+H  confirmed = ", length(which(tmpc$modeAdduct == "M+H" & tmpc$confirmed)),
   "\n",
   "M-H  detected = ", length(which(tmpc$modeAdduct == "M-H") ),
   " | ",
   "M-H  confirmed = ", length(which(tmpc$modeAdduct == "M-H" & tmpc$confirmed)),
   "\n",
   "M+Na detected = ", length(which(tmpc$modeAdduct == "M+Na") ),
   " | ",
   "M+Na confirmed = ", length(which(tmpc$modeAdduct == "M+Na" & tmpc$confirmed == TRUE)),"\n",
   "M+K  detected = ", length(which(tmpc$modeAdduct == "M+K") ),
   " | ",
   "M+K  confirmed = ", length(which(tmpc$modeAdduct == "M+K" & tmpc$confirmed)),
   "\n",
   "\n\n\n")
}


```


plotting all detections

```{r fig.width=12}

# NOTE: would be better to have two bwMethod inputs; one for one analyte case (defaults to "iterative") and one for 
# collective projection case (defaults to "scott").  

if(detectionsExist) {




  probImg              = probMap(hitsppp, win = spwin, bwMethod = bwMethod)
  
  
  spatstat::plot.im(probImg$denspp,
                    main =  paste0(lipidClass, " - all ", length(tmpm), " detections"),
                  col = spatstat::colourmap(viridis::viridis_pal(option = "inferno")(100), range = range(probImg$denspp, na.rm = T)),
                  ylim = rev(range(spwin$y)),
                  box = FALSE)
  spatstat::plot.im(probImg$nonHotspotMask, col = rgb(0,0,0,0.3), add = TRUE)

}


```

plotting confirmed/verified detections

```{r fig.width=12}
if(detectionsExist & !identical(mtspc, NA)) {
  
  subsetppp            = spatstat::subset.ppp(hitsppp, confirmed == TRUE)

#// check if empty
if(subsetppp$n == 0) {
  
  par(mfrow = c(1, 1))
  spatstat::plot.owin(spwin, 
                    main = paste0(lipidClass, " - ", "no confirmed detections"), 
                    ylim = rev(range(spwin$y)), 
                    box = FALSE)
  
  
} else {
  
 
  
  probImg              = probMap(subsetppp, win = spwin, bwMethod = bwMethod)
  
  
  spatstat::plot.im(probImg$denspp,
                    main = paste0(lipidClass, " - ", length(which(tmpc$confirmed)), " confirmed detections"),
                  col = spatstat::colourmap(viridis::viridis_pal(option = "inferno")(100), range = range(probImg$denspp, na.rm = T)),
                  ylim = rev(range(spwin$y)),
                  box = FALSE)
  spatstat::plot.im(probImg$nonHotspotMask, col = rgb(0,0,0,0.3), add = TRUE)

}
}



```