---
title: "example workflow"
author: "Denis Abu Sammour"
output:
  html_notebook:
    fig_height: 10
    fig_width: 15
  html_document:
    df_print: paged
    code_folding: hide
editor_options:
  chunk_output_type: inline
---

This notebook is used as blueprint for the shiny app development and dedicated vignettes. 

## Accompanying data

For more info on how to properly include data into packages check [this page](https://r-pkgs.org/data.html).  

**data** subdirectroy contains a pre-processed and analysis-ready RData file, containing everything needed to run an example or web-hosted shiny app. This will be included on the Github (not Git-synced).

**inst/extdata/** subdirectroy contains: (this will be part of the package but not synced by Git)  
* two txt file holding the url of the imzml (and ibd) in metaspace.  
* one tsv file containing one single continuous (full) spectrum (used for the accompanying example data).   
* one tsv file cotaning filtered swiss lipids database (used internally).     
* one csv file containing metaspace annotations for the example datase (used for the accompanying example data).   
  
**data-external** subdirectroy contains: (this is only for development, not Git-synced and will be removed later)  
* two files; imzML and ibd, processed examplary MSI data.  
  
**data-shinyWebHosted** subdirectroy is meant to contain processed ready-to-analyze data preferrably in .RData envirobnment type. This would ideally work with a web-hosted shiny app and will load RData on start. Please check [this page](https://shiny.rstudio.com/articles/persistent-data-storage.html) and let me know if this is actually an option. If they do not allow for data hosting we could always fetch the Github::moleculaR/data/RData file by downloading it and loading it into the session.
  
## Package-app inputs/outputs

**[GUI Inputs]**    
**imzmlFile**     string-browse, path to a single centroided (i.e. processed) imzML file.  
**spectrFile**    string-browse, path to a single tsv file contianing a full continuous spectrum.  
*single analyte case*  
**queryMass**     numeric-insert, m/z value. 
**probMapMethod** method used to generate the molecular probability map method.  
*collective projections case*   
**mtspc**         string-browse, path to metaspace annotation file (.csv).  
**lipidSpecies**  string-dropdown, values = `searchList$allClasses`      


**[GUI Outputs]**  
**plot**          fwhm as a function of m/z, generated after loading the single spectrum.   
*single analyte case*
**image**         ion image of the `queryMass`.   
**image**         molecular probability map of the `queryMass`.   
  
*collective projections case - if metaspace annotation file is not supplied*  
**image**         collective probability map of all instances of the chosen `lipidSpecies`.  
  
*collective projections case - if metaspace annotation file is provided*  
**image**         collective probability map of confirmed instances of the chosen `lipidSpecies`.  
**console output** confirmed identifications.  




## Workflow for package-app 


### Load data 

```{r}

library(moleculaR)
######################
#### local input #####
######################

#// MSI data - either load a local file 
imzmlFile         <- "pathToFile.imzML"                # <-- browse input-selected locally i.e. file will be 
                                                       # uploaded to the temp dir of R. 

imzmlFile         <- file.path(getwd(), "data-external", "pos-XIII-82492-msi.imzML") # temporary, just to test this nb

#// read the file into R
msData            <- readCentrData(path = imzmlFile)    # would be nice to console-notify when done reading


#// single spectrum -  load a local tsv file 
spectrFile        <- "pathToFile.tsv"                  # <-- browse input-selected locally i.e. file will be 
                                                       # uploaded to the temp dir of R. 

spectrFile        <- system.file("extdata", "pos-XIII-82492-singleSpectrum.tsv", package = "moleculaR", mustWork = TRUE)# temporary
msSpectr          <- readSingleSpect(spectrFile) 


#// load the processed swisslipids db internally
pathTosldb        <- system.file("extdata", "swisslipids-speciesOnly-sep2020.tsv", package = "moleculaR", mustWork = TRUE)
sldb              <- loadSwissDB(pathTosldb)


#// load the metaspace annotations file - supplied by user
pathToMtspc       <- "pathToFile.csv"                  # <-- browse input-selected locally
pathToMtspc       <- system.file("extdata", "metaspace_annotations.csv", package = "moleculaR", mustWork = TRUE) # temporary
mtspc             <- read.csv(file = pathToMtspc, skip = 2,header = TRUE, colClasses = "character")

#// <-- important: if mtspc is not supplied then proceed withoug confirmed annotations and do the following:
if(exists("mtspc")){
  isVerified        <- TRUE
} else {
  isVerified        <- FALSE
}



```


### preprocessing of MS data

```{r}

#// estimate fwhm from msSpectr ----
fwhmObj           = estimateFwhm(s = msSpectr, plot = TRUE) # <-- this should be run directly after the spectrFile is 
                                                            # uploaded, a plot is generated. Otherwise, one could also
                                                            # create a plot with 'plot(fwhObj)'


# bin peaks
# -- notify at start  --#
msData            =  MALDIquant::binPeaks(msData, 
                                           tolerance = getFwhm(fwhmObj, 400)/400, #focusing on lipids 
                                           method = "relaxed")
# -- notify when done --#


# filter out peaks which occur in less than 1% of the time - the 
# built-in function of MALDIquant crashes for bigger datasets
# -- notify at start  --#
msData            = filterPeaks(x = msData, minFreq = 0.01)
# -- notify when done --#


# normalization 
# -- notify at start  --#
#msData            = foldChangeNorm(msData) <-- this is optional, no need for this
# -- notify when done --#


#// create spatial window 
spwin             = spatstat::as.polygonal(spatstat::owin(mask = as.data.frame(MALDIquant::coordinates(msData))))


#// create sparse matrix representation
spData             = createSparseMat(x = msData)

# End of preproccessing
```



## one analyte at a time - m/z case


```{r}
#// input by m/z value
queryMass         = 496.33972                                   # <-- input, numeric m/z value, use this as default value for exmaple
bwMethod          = "spAutoCor"                                 # <-- input, c("spAutoCor", "scott")

# NOTE: would be better to have two bwMethod inputs; one for one analyte case (defaults to "iterative") and one for 
# collective projection case (defaults to "scott").  


```




This should be the plotting output - everything together

```{r fig.width=10, fig.height=12}


#// compute the regular ion image
sppIonImage      = searchAnalyte(m = queryMass, 
                                  fwhm = getFwhm(fwhmObj, queryMass), 
                                  spData = spData, 
                                  wMethod = "sum")


#// check if hits is empty
if(sppIonImage$n == 0)
{
  
  par(mfrow = c(1, 1))
  #// image without masking
  spatstat::plot.owin(sppIonImage$window, 
                  main = paste0("No insances of m/z ", round(queryMass, 4), " were detected"), 
                  ylim = rev(sppIonImage$window$yrange), 
                  box = FALSE)
  
  rm(sppIonImage)
  
} else{ # if there are hits then proceed with MPM computations
  
  # compute rastered image of the sppIonImage 
  ionImage        <- spatstat::pixellate(sppIonImage,
                                weights = sppIonImage$marks$intensity,
                                W = spatstat::as.mask(sppIonImage$window,
                                                      dimyx=c(diff(sppIonImage$window$yrange),
                                                              diff(sppIonImage$window$xrange))),
                                padzero = FALSE, savemap = FALSE)

  
  # compute sppMoi (spatial point pattern of the analyte)
  sppMoi          <- searchAnalyte(m = queryMass, 
                                  fwhm = getFwhm(fwhmObj, queryMass), 
                                  spData = spData)

  

  
  #// compute MPM - default parameters
  probImg         <- probMap(sppMoi)

  txt  <- paste0("m/z ", round(queryMass, 4), " Â± ", round(getFwhm(fwhmObj, queryMass), 4))
  plot(probImg, what = "detailed", analyte = txt, ionImage = ionImage)
  
  rm(probImg, txt, sppMoi, ionImage, sppIonImage)

}
```



## Collective projection case - lipid classes

```{r fig.width=8}

#// Possible inputs: {

adduct <- c("M+H", "M+Na", "M+K") # <-- multiple choice possible, values =  c("M-H", "M+H", "M+Na", "M+K")
confirmedOnly <- TRUE             # either TRUE of FALSE, whether to only include verified (confirmed) analytes. 

#}

if(isVerified){
  verifiedMasses = as.numeric(mtspc$mz)
}else{
  verifiedMasses = NA
}


# User needs to be notified that they have to wait
cat("Batch lipid search is ongoing - this will take several minutes - \n")

searchList <- batchLipidSearch(spData = spData, fwhmObj = fwhmObj, sldb = sldb, 
                               adduct = adduct, numCores = 4L, 
                               verifiedMasses = verifiedMasses,
                               confirmedOnly = confirmedOnly, verbose = TRUE)

```


plotting all detections of a chosen lipid class

```{r fig.width=12, fig.height=10}
#// choose one lipid species
lipidClass <- "PC(x:x)"                        # <-- Input, selection from drop-down, values = searchList$allClasses



if(searchList$hitsList[[lipidClass]]$n == 0) {
  
  
  
   par(mfrow = c(1, 1))

  #// empty window
  spatstat::plot.owin(searchList$hitsList[[lipidClass]]$window,
                  main = paste0("No insances of ", lipidClass, " were detected"),
                  ylim = rev(searchList$hitsList[[lipidClass]]$window$yrange),
                  box = FALSE)
  
  
} else {


  probImg <- probMap(searchList$hitsList[[lipidClass]], bwMethod = "scott", sqrtTansform = TRUE) # fixed arguments
  
  plot(probImg, what = "detailed", analyte = paste0(lipidClass, " - n=", length(probImg$sppMoi$metaData$mzVals)))
  
  rm(probImg)

  
}
```

# Custom CPPMs

the following combined (huge) SPP will be used throughout the rest of the calculations. 

```{r}

# User needs to be notified that they have to wait
cat("combining all lyso-GPLs into one SPP object - this should take several minutes - \n")
lysoGplsSumSpp <- superImposeAnalytes(searchList$hitsList, 
                                      spWin = spatstat::as.polygonal(spatstat::owin(mask = spData$coordinates)))




```


## ion milieus

```{r fig.width=12, fig.height=10}
detectedAdducts <- unique(lysoGplsSumSpp$metaData$adduct) 

sppList <- setNames(vector("list", length(detectedAdducts)), detectedAdducts)

# subsetting
sppList[["M+K"]]     <- subsetAnalytes(lysoGplsSumSpp, adduct == "M+K")
sppList[["M+Na"]]    <- subsetAnalytes(lysoGplsSumSpp, adduct == "M+Na")
sppList[["M+H"]]     <- subsetAnalytes(lysoGplsSumSpp, adduct == "M+H")

lipidGroup <-"(lyso)GPLs"


```

input for the specific adduct

```{r fig.width=12, fig.height=10}
      
igroup              = "M+K" # <- input, dropdown from 'names(sppList)'


if(sppList[[igroup]]$n == 0) {
  
  
  
   par(mfrow = c(1, 1))

  #// empty window
  spatstat::plot.owin(lysoGplsSumSpp$window,
                  main = paste0("No insances of ", igroup, " were detected"),
                  ylim = rev(lysoGplsSumSpp$window$yrange),
                  box = FALSE)
  
  
  
} else {
  
probImg    = probMap(sppList[[igroup]], bwMethod = "scott", sqrtTansform = TRUE)

if(probImg$sppMoi$n > 50000) {
  cat("plotting ", format(probImg$sppMoi$n, big.mark = ","), " points - this takes time! \n")
}
plot(probImg, what = "detailed", analyte = paste0(igroup, " of ", lipidGroup, " - n=", length(probImg$sppMoi$metaData$mzVals)))

rm(probImg)

}
```



## lipid saturation

```{r fig.width=12, fig.height=10}
detectedSaturation <- c("sat", "mono-unsat", "di-unsat", "poly-unsat")

sppList <- setNames(vector("list", length(detectedSaturation)), detectedSaturation)

# subsetting
sppList[["sat"]]   <- subsetAnalytes(lysoGplsSumSpp, numDoubleBonds == 0)
sppList[["mono-unsat"]]   <- subsetAnalytes(lysoGplsSumSpp, numDoubleBonds == 1)
sppList[["di-unsat"]]   <- subsetAnalytes(lysoGplsSumSpp, numDoubleBonds == 2)
sppList[["poly-unsat"]]   <- subsetAnalytes(lysoGplsSumSpp, numDoubleBonds > 2)

lipidGroup <-"(lyso)GPLs"

```

input for the specific saturation

```{r fig.width=12, fig.height=10}
igroup              = "mono-unsat" # <- input, dropdown from 'names(sppList)'


if(sppList[[igroup]]$n == 0) {
  
  
  
   par(mfrow = c(1, 1))

  #// empty window
  spatstat::plot.owin(lysoGplsSumSpp$window,
                  main = paste0("No insances of ", igroup, " lipids were detected"),
                  ylim = rev(lysoGplsSumSpp$window$yrange),
                  box = FALSE)
  
  
} else {
  
probImg    = probMap(sppList[[igroup]], bwMethod = "scott", sqrtTansform = TRUE)

if(probImg$sppMoi$n > 50000) {
  cat("plotting ", format(probImg$sppMoi$n, big.mark = ","), " points - this takes time! \n")
}
plot(probImg, what = "detailed", analyte = paste0(igroup, " of ", lipidGroup, " - n=", length(probImg$sppMoi$metaData$mzVals)))


}



```



