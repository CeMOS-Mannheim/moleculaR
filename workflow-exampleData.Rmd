---
title: "shiny app example workflow - Example & web-hosted"
author: "Denis Abu Sammour"
output:
  html_notebook:
    fig_height: 10
    fig_width: 15
  html_document:
    df_print: paged
    code_folding: hide
editor_options:
  chunk_output_type: inline
---

This notebook is used as blueprint for the shiny app development and dedicated vignettes. 

## Accompanying data

For more info on how to properly include data into packages check [this page](https://r-pkgs.org/data.html).  

**data** subdirectroy contains a pre-processed and analysis-ready RData file, containing everything needed to run an example or web-hosted shiny app. This will be included on the Github (not Git-synced).

**inst/extdata/** subdirectroy contains: (this will be part of the package but not synced by Git)  
* two txt file holding the url of the imzml (and ibd) in metaspace.  
* one tsv file containing one single continuous (full) spectrum (used for the accompanying example data).   
* one tsv file cotaning filtered swiss lipids database (used internally).     
* one csv file containing metaspace annotations for the example datase (used for the accompanying example data).   
  
**data-external** subdirectroy contains: (this is only for development, not Git-synced and will be removed later)  
* two files; imzML and ibd, processed examplary MSI data.  
  
**data-shinyWebHosted** subdirectroy is meant to contain processed ready-to-analyze data preferrably in .RData envirobnment type. This would ideally work with a web-hosted shiny app and will load RData on start. Please check [this page](https://shiny.rstudio.com/articles/persistent-data-storage.html) and let me know if this is actually an option. If they do not allow for data hosting we could always fetch the Github::moleculaR/data/RData file by downloading it and loading it into the session.   
  
## Package-app inputs/outputs

**[GUI Inputs]**    
*single analyte case*  
**queryMass**     numeric-insert, m/z value.  
**bwMethod**      No need to specify this anymore, let's keep it simple and leave it at default value (as in the paper)
**p-value**       The p-value threshold to be used for the hypothesis testing. Defaults to 0.05. 
**correction**    The method used for p-values correction, drop down -> c("bonferroni", "BH")

*collective projections case*   
**lipidClass**  string-dropdown, values = `searchList$allClasses`      


**[GUI Outputs]**  
**plot**          fwhm as a function of m/z, generated after loading the single spectrum. 

*single analyte case*
**image**         ion image of the `queryMass`.   
**image**         MPM of the `queryMass`.

*collective projections case*  
**image**         collective projection of confirmed instances of the chosen `lipidClass`.  
**image**         CPM of `lipidClass`.  


## Workflow for example data + web-hosted app 


### Load data 

```{r}
library(moleculaR)

#// load saved image
data("processed-example-Data")

#-> this loads "msData", "sldb", "mtspc", "fwhmObj"


#// create sparse matrix representation
spData             = createSparseMat(x = msData)


# Done!
```

### plot the fwhm(m/z) 

```{r}

plot(fwhmObj)


```

## one analyte at a time - m/z case


```{r}
#// input by m/z value
queryMass         = 788.5447                                   # <-- input, numeric m/z value, use this as default value for exmaple

# NOTE: let's fix the bwMethod inputs; "spAutoCor" for MPM case (single analyte) and "scott" for multiple analytes (CPM).   

```


This should be the plotting output - everything together

```{r fig.width=10, fig.height=12}


#// compute the regular ion image
sppIonImage      = searchAnalyte(m = queryMass, 
                                  fwhm = getFwhm(fwhmObj, queryMass), 
                                  spData = spData, 
                                  wMethod = "sum")


#// check if hits is empty
if(sppIonImage$n == 0)
{
  
  par(mfrow = c(1, 1))
  #// image without masking
  spatstat::plot.owin(sppIonImage$window, 
                  main = paste0("No insances of m/z ", round(queryMass, 4), " were detected"), 
                  ylim = rev(sppIonImage$window$yrange), 
                  box = FALSE)
  
  rm(sppIonImage)
  
} else{ # if there are hits then proceed with MPM computations
  
  # compute rastered image of the sppIonImage 
  ionImage        <- spatstat::pixellate(sppIonImage,
                                weights = sppIonImage$marks$intensity,
                                W = spatstat::as.mask(sppIonImage$window,
                                                      dimyx=c(diff(sppIonImage$window$yrange),
                                                              diff(sppIonImage$window$xrange))),
                                padzero = FALSE, savemap = FALSE)

  
  # compute sppMoi (spatial point pattern of the analyte)
  sppMoi          <- searchAnalyte(m = queryMass, 
                                  fwhm = getFwhm(fwhmObj, queryMass), 
                                  spData = spData)

  

  
  #// compute MPM - default parameters
  probImg         <- probMap(sppMoi)

  txt  <- paste0("m/z ", round(queryMass, 4), " Â± ", round(getFwhm(fwhmObj, queryMass), 4))
  plot(probImg, what = "detailed", analyte = txt, ionImage = ionImage)
  
  rm(probImg, txt, sppMoi, ionImage, sppIonImage)

}
```


## Collective projection case - lipid classes

```{r fig.width=8}

# User needs to be notified that they have to wait
cat("Batch lipid search is ongoing - this will take several minutes - \n")

searchList <- batchLipidSearch(spData = spData, fwhmObj = fwhmObj, sldb = sldb, 
                               adduct = c("M+H", "M+Na", "M+K"), numCores = 4L, verifiedMasses = as.numeric(mtspc$mz),
                               confirmedOnly = TRUE, verbose = TRUE)

```


plotting all detections of a chosen lipid class

```{r fig.width=12, fig.height=10}
#// choose one lipid species
lipidClass <- "PA(x:x)"                        # <-- Input, selection from drop-down, values = searchList$allClasses



if(searchList$hitsList[[lipidClass]]$n == 0) {
  
  
  
   par(mfrow = c(1, 1))

  #// empty window
  spatstat::plot.owin(searchList$hitsList[[lipidClass]]$window,
                  main = paste0("No insances of ", lipidClass, " were detected"),
                  ylim = rev(searchList$hitsList[[lipidClass]]$window$yrange),
                  box = FALSE)
  
  
} else {


  probImg <- probMap(searchList$hitsList[[lipidClass]], bwMethod = "scott", sqrtTansform = TRUE) # fixed arguments
  
  plot(probImg, what = "detailed", analyte = paste0(lipidClass, " - n=", length(probImg$sppMoi$metaData$mzVals)))
  
  rm(probImg)

  
}
```

## Custom CPPMs

the following combined (huge) SPP will be used throughout the rest of the calculations. 

```{r}

# User needs to be notified that they have to wait
cat("combining all lyso-GPLs into one SPP object - a couple of minutes - \n")
lysoGplsSumSpp <- superImposeAnalytes(searchList$hitsList, 
                                      spWin = spatstat::as.polygonal(spatstat::owin(mask = spData$coordinates)))




```


## ion milieus

```{r fig.width=12, fig.height=10}
detectedAdducts <- unique(lysoGplsSumSpp$metaData$adduct) 

sppList <- setNames(vector("list", length(detectedAdducts)), detectedAdducts)

# subsetting
sppList[["M+K"]]     <- subsetAnalytes(lysoGplsSumSpp, adduct == "M+K")
sppList[["M+Na"]]    <- subsetAnalytes(lysoGplsSumSpp, adduct == "M+Na")
sppList[["M+H"]]     <- subsetAnalytes(lysoGplsSumSpp, adduct == "M+H")

lipidGroup <-"(lyso)GPLs"


```

input for the specific adduct

```{r fig.width=12, fig.height=10}
      
igroup              = "M+K" # <- input, dropdown from 'names(sppList)'


if(sppList[[igroup]]$n == 0) {
  
  
  
   par(mfrow = c(1, 1))

  #// empty window
  spatstat::plot.owin(lysoGplsSumSpp$window,
                  main = paste0("No insances of ", igroup, " were detected"),
                  ylim = rev(lysoGplsSumSpp$window$yrange),
                  box = FALSE)
  
  
  
} else {
  
probImg    = probMap(sppList[[igroup]], bwMethod = "scott", sqrtTansform = TRUE)

if(probImg$sppMoi$n > 50000) {
  cat("plotting ", format(probImg$sppMoi$n, big.mark = ","), " points - this takes time! \n")
}
plot(probImg, what = "detailed", analyte = paste0(igroup, " of ", lipidGroup, " - n=", length(probImg$sppMoi$metaData$mzVals)))

rm(probImg)

}
```



## lipid saturation

```{r fig.width=12, fig.height=10}
detectedSaturation <- c("sat", "mono-unsat", "di-unsat", "poly-unsat")

sppList <- setNames(vector("list", length(detectedSaturation)), detectedSaturation)

# subsetting
sppList[["sat"]]   <- subsetAnalytes(lysoGplsSumSpp, numDoubleBonds == 0)
sppList[["mono-unsat"]]   <- subsetAnalytes(lysoGplsSumSpp, numDoubleBonds == 1)
sppList[["di-unsat"]]   <- subsetAnalytes(lysoGplsSumSpp, numDoubleBonds == 2)
sppList[["poly-unsat"]]   <- subsetAnalytes(lysoGplsSumSpp, numDoubleBonds > 2)

lipidGroup <-"(lyso)GPLs"

```

input for the specific saturation

```{r fig.width=12, fig.height=10}
igroup              = "mono-unsat" # <- input, dropdown from 'names(sppList)'


if(sppList[[igroup]]$n == 0) {
  
  
  
   par(mfrow = c(1, 1))

  #// empty window
  spatstat::plot.owin(lysoGplsSumSpp$window,
                  main = paste0("No insances of ", igroup, " lipids were detected"),
                  ylim = rev(lysoGplsSumSpp$window$yrange),
                  box = FALSE)
  
  
} else {
  
probImg    = probMap(sppList[[igroup]], bwMethod = "scott", sqrtTansform = TRUE)

if(probImg$sppMoi$n > 50000) {
  cat("plotting ", format(probImg$sppMoi$n, big.mark = ","), " points - this takes time! \n")
}
plot(probImg, what = "detailed", analyte = paste0(igroup, " of ", lipidGroup, " - n=", length(probImg$sppMoi$metaData$mzVals)))


}



```


