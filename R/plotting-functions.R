#' Plot a spectrum focusing on a specific mass-range
#'
#' This function plots a spectrum (`MassPeaks` or `MassSpectrum`) and provides
#' a focus on a mass range around a given m/z of interest taking into
#' consideration the fwhm at that mass.
#'
#' @param x an object of type `MassPeaks` or `MassSpectrum`. Either a single
#' spectrum or a mean spectrum (see `?MALDIquant::mergeMassPeaks`).
#' @param m a numeric (vector), the m/z value(S) at which to do the plotting.
#' @param fwhm a numeric (vector), the fwhm value(s) at `m`, normally generated by `getFwhm`.
#' Must have the same length as `m`.
#' @param sigmalim an integer, how many sigmas (of the calculated Gaussian)
#' around `m` should be considered in the plot. Note that the superimposed
#' Gaussian always spans `m ± sigma`.
#' @param col a character (vector), colors used for the m/z values in `m`.
#'
#' @return
#' a plot.
#'
#' @export
#'

focusPlot <- function(x, m, fwhm, sigmalim = 6, col = NULL){

         m <- sort(m)

         if(length(m) != length(fwhm)){
                  stop("length(m) is not equal to length(fwhm)!\n")
         }


         # find sigma intervals
         sigma <- fwhm/(2*sqrt(2*log(2)))
         s3 <- sigma * 3
         sxlim <- sigma * sigmalim

         # scale the y-axis intensities according to the focus region
         idx <- which(x@mass > min(m-sxlim) & x@mass < max(m+sxlim))

         if(length(idx) > 1){
                  yrange <- range(x@intensity[idx])
         }

         if(length(idx) == 1){
                  yrange <- c(0, x@intensity[idx])
         }

         if(length(idx) == 0){
                  warning("No peaks detected in the given mass range, consider increasing ",
                          "'sigmalim'.\n")
                  yrange <- c(0, median(x@intensity))
         }

         xrange <- c(min(m-sxlim), max(m+sxlim))

         par(mar= c(5,5,5,7))

         MALDIquant::plot(x, xlim = xrange, ylim = yrange,
                          frame = FALSE, axes = FALSE, ylab = "",
                          xlab = "",
                          main = paste0("m/z " ,round(m, 4),
                                        " ± ", round(s3, 4)),
                          lwd = 2, cex.lab = 1.25, cex.axis = 1.25)

         axis(1, at = pretty(xrange), col = "black",
              lwd = 2, cex = 1.25, col.axis = "black",
              cex.axis = 1.25, lty = "solid")

         mtext(substitute(paste(italic("m/z"))), side=1, line=2, cex=1.25, col="black")

         axis(2, at = pretty(yrange),
              col = "black", labels = format(pretty(yrange), scientific = TRUE),
              lwd = 2, cex = 1.25, col.axis = "black",
              cex.axis = 1.25, line = 1.5, lty = "solid")

         mtext("Intensity", side=2, line=4, cex=1.25, col="black")

         if(is.null(col)){
                  col <- rainbow(length(m))
         } else {
                  if(length(col) != length(m)){
                           warning("'col' has to have the same length as 'm'. The input has been ignored.\n")
                           col <- rainbow(length(m))
                  }
         }

         for(ii in 1:length(m)){
                  axis(1, at=m[ii], tick = T, labels="", col=col[ii],
                       lwd = 1.5, cex = 1.25, col.axis = col[ii],
                       gap.axis = 0, cex.axis = 1.25)





                  # gaussian visualization
                  gxx <- seq(m[ii]-s3[ii], m[ii]+s3[ii], 0.0001)
                  gyy <- .gf(x = gxx, mu = m[ii], sigma = sigma[ii])

                  gyy <- .linMap(gyy, yrange[1], yrange[2])

                  polygon(x = c(gxx[1], gxx, gxx[length(gxx)], gxx[1]),
                          y = c(0, gyy, 0, 0),
                          col =  to.transparent(col[ii], 0.25),
                          border = to.transparent(col[ii], 0.25))

                  abline(v = m[ii], lty="dashed", lwd = 0.75, col = col[ii])



         }

         par(new=TRUE)
         plot(1, axes = FALSE, type="n", xlab="", ylab="", xlim=xrange, ylim=c(0, 1), frame = FALSE)
         # axis(4, at=pretty(c(0,1)), col = "coral2",
         #      lwd = 2, cex = 1.25, col.axis = "coral2",
         #      cex.axis = 1.25, line = 1.5)
         axis(4, at=pretty(c(0,1)), col = "black",
              lwd = 2, cex = 1.25, col.axis = "black",
              cex.axis = 1.25, line = 1.5, lty = "dashed")
         mtext("Gaussian Weights", side=4, line=4, cex=1.25, col="black")

         # legend("topright",
         #        legend = c(paste0("fwhm = ", round(fwhm, 4)),
         #                   paste0("sigma = ", round(sigma, 4))),
         #        bty = "n",
         #        col = col)


}

# Gaussian function
.gf <- function(x, mu, sigma){
         1/(sqrt(2 * pi) * sigma) * exp(-((x - mu)^2/(2 * sigma^2)))
}

# linear mapping of values into a custom range
.linMap <- function(i, a, b) approxfun(range(i), c(a, b))(i)

